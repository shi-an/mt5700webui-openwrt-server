#!/bin/sh /etc/rc.common

START=99
STOP=10

USE_PROCD=1
PROG=/usr/bin/at-webserver
PROG_NAME="at-webserver"

# 加载 UCI 函数库（必须在文件顶部）
. /lib/functions.sh

start_service() {
	local enabled
	
	# 输出到系统日志
	logger -t at-webserver "开始启动服务..."
	
	# 确保最新的 UCI 已提交
	uci -q commit at-webserver
	
	# 加载配置
	config_load at-webserver
	config_get_bool enabled config enabled 0
	
	if [ "$enabled" -eq 0 ]; then
		logger -t at-webserver "服务已禁用，退出启动"
		echo "AT WebServer is disabled in configuration"
		return 1
	fi
	
	# 检查二进制文件是否存在
	if [ ! -f "$PROG" ]; then
		logger -t at-webserver "错误：找不到可执行文件 $PROG"
		echo "Error: $PROG not found"
		return 1
	fi
	
	# 自动检测并添加 USB 串口设备 ID（如果需要）
	detect_and_add_usb_serial() {
		# 仅在发现 MT5700 且尚无 ttyUSB* 时处理
		if ! lsusb -d 3466:3301 >/dev/null 2>&1; then
			return 0
		fi
		if ls /dev/ttyUSB* >/dev/null 2>&1; then
			return 0
		fi

		# 加载必要模块（忽略已加载）
		modprobe usbserial 2>/dev/null || true
		modprobe option 2>/dev/null || true
		modprobe qcserial 2>/dev/null || true

		# 兼容不同内核的 new_id 路径
		local NEW_ID=""
		[ -e /sys/bus/usb-serial/drivers/option/new_id ] && NEW_ID=/sys/bus/usb-serial/drivers/option/new_id
		[ -z "$NEW_ID" ] && [ -e /sys/bus/usb-serial/drivers/option1/new_id ] && NEW_ID=/sys/bus/usb-serial/drivers/option1/new_id
		if [ -z "$NEW_ID" ]; then
			logger -t at-webserver "option(1) driver not ready, skip new_id"
			return 0
		fi

		# 仅绑定一次
		if ! grep -q "3466[[:space:]]\+3301" "$NEW_ID" 2>/dev/null; then
			echo "3466 3301" > "$NEW_ID" 2>/dev/null && \
				logger -t at-webserver "已添加 USB 设备 ID: 3466:3301 to $(basename $(dirname $NEW_ID))" || \
				logger -t at-webserver "添加 USB 设备 ID 失败: 3466:3301"
		fi

		# 等待设备节点出现
		sleep 1
	}
	
	detect_and_add_usb_serial
	
	# 配置防火墙规则（控制外网访问和模块访问限制）
	setup_firewall() {
		local allow_wan
		local ws_port
		local module_allow_wan
		local restrict_module
		local module_host
		local module_port
		
		config_get_bool allow_wan config websocket_allow_wan 0
		config_get ws_port config websocket_port 8765
		config_get_bool module_allow_wan config network_allow_wan 0
		config_get_bool restrict_module config network_restrict_access 0
		config_get module_host config network_host '192.168.8.1'
		config_get module_port config network_port '20249'
		
		# 删除旧的 WebSocket WAN 规则（阻止）
		local rule_name="at_webserver_wan_block"
		local rule_idx=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1 | head -n1)
		if [ -n "$rule_idx" ]; then
			uci delete firewall.@rule[$rule_idx] 2>/dev/null
		fi
		
		# 删除旧的 WebSocket WAN 规则（允许）
		rule_name="at_webserver_wan_allow"
		rule_idx=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1 | head -n1)
		if [ -n "$rule_idx" ]; then
			uci delete firewall.@rule[$rule_idx] 2>/dev/null
		fi
		
		# 删除旧的模块 LAN 访问限制规则
		rule_name="at_module_restrict"
		rule_idx=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1 | head -n1)
		if [ -n "$rule_idx" ]; then
			uci delete firewall.@rule[$rule_idx] 2>/dev/null
		fi
		
		# 删除旧的模块 WAN 访问限制规则（阻止）
		rule_name="at_module_wan_block"
		rule_idx=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1 | head -n1)
		if [ -n "$rule_idx" ]; then
			uci delete firewall.@rule[$rule_idx] 2>/dev/null
		fi
		
		# 删除旧的模块 WAN 访问规则（允许）
		rule_name="at_module_wan_allow"
		rule_idx=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1 | head -n1)
		if [ -n "$rule_idx" ]; then
			uci delete firewall.@rule[$rule_idx] 2>/dev/null
		fi
		
		uci commit firewall
		
		# 模块外网访问控制
		if [ "$module_allow_wan" -eq 1 ]; then
			# 允许外网访问模块，添加 ACCEPT 规则
			uci add firewall rule >/dev/null
			uci set firewall.@rule[-1].name="at_module_wan_allow"
			uci set firewall.@rule[-1].src='wan'
			uci set firewall.@rule[-1].dest='*'
			uci set firewall.@rule[-1].dest_ip="$module_host"
			uci set firewall.@rule[-1].dest_port="$module_port"
			uci set firewall.@rule[-1].proto='tcp'
			uci set firewall.@rule[-1].target='ACCEPT'
			uci set firewall.@rule[-1].enabled='1'
			logger -t at-webserver "已允许外网访问模块 AT 端口: $module_host:$module_port (警告: 不安全!)"
		else
			# 禁止外网访问模块，添加 REJECT 规则
			uci add firewall rule >/dev/null
			uci set firewall.@rule[-1].name="at_module_wan_block"
			uci set firewall.@rule[-1].src='wan'
			uci set firewall.@rule[-1].dest='*'
			uci set firewall.@rule[-1].dest_ip="$module_host"
			uci set firewall.@rule[-1].dest_port="$module_port"
			uci set firewall.@rule[-1].proto='tcp'
			uci set firewall.@rule[-1].target='REJECT'
			uci set firewall.@rule[-1].enabled='1'
			logger -t at-webserver "已禁止外网访问模块 AT 端口: $module_host:$module_port"
		fi
		
		# WebSocket 外网访问控制
		if [ "$allow_wan" -eq 1 ]; then
			# 允许外网访问，添加 ACCEPT 规则
			uci add firewall rule >/dev/null
			uci set firewall.@rule[-1].name="at_webserver_wan_allow"
			uci set firewall.@rule[-1].src='wan'
			uci set firewall.@rule[-1].proto='tcp'
			uci set firewall.@rule[-1].dest_port="$ws_port"
			uci set firewall.@rule[-1].target='ACCEPT'
			uci set firewall.@rule[-1].enabled='1'
			logger -t at-webserver "已允许外网访问 WebSocket (端口 $ws_port)"
		else
			# 禁止外网访问，添加 REJECT 规则（更明确）
			uci add firewall rule >/dev/null
			uci set firewall.@rule[-1].name="at_webserver_wan_block"
			uci set firewall.@rule[-1].src='wan'
			uci set firewall.@rule[-1].proto='tcp'
			uci set firewall.@rule[-1].dest_port="$ws_port"
			uci set firewall.@rule[-1].target='REJECT'
			uci set firewall.@rule[-1].enabled='1'
			logger -t at-webserver "已禁止外网访问 WebSocket (端口 $ws_port)"
		fi
		
		# 如果启用模块访问限制，阻止局域网其他设备访问模块
		if [ "$restrict_module" -eq 1 ]; then
			uci add firewall rule >/dev/null
			uci set firewall.@rule[-1].name="at_module_restrict"
			uci set firewall.@rule[-1].src='lan'
			uci set firewall.@rule[-1].dest='*'
			uci set firewall.@rule[-1].dest_ip="$module_host"
			uci set firewall.@rule[-1].dest_port="$module_port"
			uci set firewall.@rule[-1].proto='tcp'
			uci set firewall.@rule[-1].target='REJECT'
			uci set firewall.@rule[-1].enabled='1'
			logger -t at-webserver "已限制模块访问: 仅路由器本身可访问 $module_host:$module_port"
		else
			logger -t at-webserver "模块访问: 允许局域网设备访问 $module_host:$module_port"
		fi
		
		uci commit firewall
		# 重新加载防火墙
		/etc/init.d/firewall reload >/dev/null 2>&1
	}
	
	setup_firewall
	
	# 确保没有旧进程在运行
	killall -q -9 "$PROG_NAME" 2>/dev/null
	sleep 1
	
	logger -t at-webserver "配置 procd 实例..."
	echo "Starting AT WebServer..."
	
	# 启动 procd 服务（不指定实例名，使用默认 instance1）
	procd_open_instance
	procd_set_param command "$PROG"
	procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-5}
	procd_set_param stdout 1
	procd_set_param stderr 1
	procd_set_param pidfile /var/run/at-webserver.pid
	procd_close_instance
	
	logger -t at-webserver "服务启动配置完成，等待 procd 启动进程"
	echo "AT WebServer started successfully"
}

stop_service() {
	logger -t at-webserver "停止服务..."
	echo "Stopping AT WebServer..."
	
	# 强制杀死所有相关进程
	killall -q -9 "$PROG_NAME" 2>/dev/null
	
	# 清理 pidfile
	rm -f /var/run/at-webserver.pid
	
	# 清理防火墙规则
	# 清理 WebSocket WAN 阻止规则
	local rule_name="at_webserver_wan_block"
	local rule_idx=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1 | head -n1)
	if [ -n "$rule_idx" ]; then
		uci delete firewall.@rule[$rule_idx] 2>/dev/null
	fi
	
	# 清理 WebSocket WAN 允许规则
	rule_name="at_webserver_wan_allow"
	rule_idx=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1 | head -n1)
	if [ -n "$rule_idx" ]; then
		uci delete firewall.@rule[$rule_idx] 2>/dev/null
	fi
	
	# 清理模块 LAN 访问限制规则
	rule_name="at_module_restrict"
	rule_idx=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1 | head -n1)
	if [ -n "$rule_idx" ]; then
		uci delete firewall.@rule[$rule_idx] 2>/dev/null
	fi
	
	# 清理模块 WAN 阻止规则
	rule_name="at_module_wan_block"
	rule_idx=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1 | head -n1)
	if [ -n "$rule_idx" ]; then
		uci delete firewall.@rule[$rule_idx] 2>/dev/null
	fi
	
	# 清理模块 WAN 允许规则
	rule_name="at_module_wan_allow"
	rule_idx=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1 | head -n1)
	if [ -n "$rule_idx" ]; then
		uci delete firewall.@rule[$rule_idx] 2>/dev/null
	fi
	
	uci commit firewall
	/etc/init.d/firewall reload >/dev/null 2>&1
	logger -t at-webserver "已清理所有防火墙规则"
	
	sleep 1
	logger -t at-webserver "服务已停止"
	echo "AT WebServer stopped"
}

reload_service() {
	logger -t at-webserver "重新加载配置..."
	echo "Reloading AT WebServer configuration..."
	
	# 提交最新配置
	uci -q commit at-webserver
	
	# 强制停止所有相关进程
	killall -q -9 "$PROG_NAME" 2>/dev/null
	rm -f /var/run/at-webserver.pid
	
	# 等待进程完全停止
	sleep 3
	
	# 重新启动服务
	start_service
	
	logger -t at-webserver "配置重新加载完成"
}

service_triggers() {
	procd_add_reload_trigger "at-webserver"
}
